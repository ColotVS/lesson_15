public class lesson_15_15 {
    //Проверяемые исключения: throws, checked exceptions

    //Все исключения в Java делятся на 2 категории — проверяемые (checked) и непроверяемые (unchecked).
    //Все исключения, унаследованные от классов RuntimeException и Error,
    //считаются unchecked-исключениями, все остальные — checked-исключениями.

    //В чем же основное отличие checked-исключений от unchecked?
    //К checked-исключениям есть дополнительные требования. Звучат они примерно так.

    //Требование 1
    //Если метод выбрасывает checked-исключение,
    //он должен содержать тип этого исключения в своем заголовке (сигнатуре метода).
    //Чтобы все методы, которые вызывают данный метод, знали о том,
    //что в нем может возникнуть такое «важное исключение».
    //Указывать checked-исключения надо после параметров метода после ключевого слова throws
    //(не путать со throw). Выглядит это примерно так:
    //тип метод (параметры) throws исключение

    /*
    checked-исключение	                                    unchecked-исключение
    public void calculate(int n) throws Exception           public void calculate(n)
    {                                                       {
    if (n == 0)                                             if (n == 0)
        throw new Exception("n равно нулю!");                   throw new RuntimeException("n равно нулю!");
    }                                                       }
     */

    //В примере справа наш код выкидывает unchecked-исключение — никаких дополнительных действий не нужно.
    //В примере слева метод выкидывает checked-исключение,
    //поэтому в сигнатуру метода добавили ключевое слово throws и указали тип исключения.
    //Если метод планирует выкидывать несколько checked-исключений,
    //все их нужно указать после ключевого слова throws через запятую. Порядок неважен.

    //Требование 2
    //Если вы вызываете метод, у которого в сигнатуре прописаны checked-исключения,
    //то вы не можете проигнорировать этот факт.
    //Вы должны либо перехватить все эти исключения, добавив блоки catch для каждого из них,
    //либо добавить их в throws своего метода.
    //Мы как бы говорим себе: эти исключения настолько важные, что мы обязательно должны их перехватить.
    //А если мы не знаем, как их перехватить,
    //мы должны уведомить тех, кто будет вызывать наш метод, что в нем могут возникнуть такие исключения.

    //Представим, что мы пишем метод, который должен создать мир, населенный людьми.
    //Начальное количество человек передается в качестве параметра.
    //Тогда мы должны добавить исключения, если людей слишком мало.
    /*
    public void создатьМир(int n) throws ПустойМир,ОдинокийМир
    {
    if (n == 0)
        throw new ПустойМир("Людей вообще нет!");
    if (n == 1)
        throw new ОдинокийМир("Слишком мало людей!");
    System.out.println("Создан прекрасный мир. Население: " + n);
    }
    */

    //Вызов этого метода можно обработать 3 способами:

    //1. Не перехватываем возникающие исключения
    //Чаще всего это делается в случае, когда в методе не известно, как правильно обработать эту ситуацию.
    /*
    public void создатьНаселенныйМир(int population) throws ПустойМир, ОдинокийМир
    {
    создатьМир(population);
    }
    */
    //Вызывающий метод не перехватывает исключения и
    //вынужден информировать о них других: добавить их себе в throws

    //2. Перехватывать часть исключений
    //Обрабатываем понятные ошибки, непонятные — прокидываем в вызывающий метод.
    //Для этого нужно добавить их название в throws:
    /*
    public void создатьНепустойМир(int population throws ПустойМир
    {
        try
        {
            создатьМир(population);
        }
        catch (ОдинокийМир e)
        {
            e.printStackTrace();
        }
    }
     */

    //Вызывающий метод перехватывает только одно checked-исключение – ОдинокийМир,
    //второе он должен добавить в свою сигнатуру: указать после слова throws

    //3. Перехватываем все исключения
    //Если метод не прокидывает исключения вызывающему методу,
    //вызывающий метод всегда будет уверен, что все выполнилось хорошо.
    //И не сможет предпринять никаких действий, чтобы исправить ситуацию.
    /*
    public void создатьЛюбойМир(int population)
    {
        try
        {
            создатьМир(population);
        }
        catch(ОдинокийМир e)
        {
            e.printStackTrace();
        }
        catch(ПустойМир e)
        {
            e.printStackTrace();
        }
    }
    */
    //В этом методе перехватываются все ошибки. Вызывающий метод будет уверен, что все прошло отлично.

}
